///Copyright 2017-2020 Ian Thecleric; all rights reserved.

using UnityEngine;
using System.Collections;

/// <summary>
/// Spawns one wave of enemies. Trigger it by a Spawn Prop if you want a visible spawn source and/or if the spawn source can be destroyed.
/// </summary>
[RequireComponent(typeof(SpawnerPathUpdater))]
public class Spawner : TriggeringObject
{
	[HideInInspector]
	//[SerializeField]
	private Vector2[] path;
	[HideInInspector]
	//[SerializeField]
	private int phase2PathIndex;

	[SerializeField]
	private bool isSmooth = true;
	[SerializeField]
	private Transform[] wayPoints = new Transform[0];
	[SerializeField]
	EnemyMovePath enemyToSpawnRef = null;
	[SerializeField]
	private int phase2WpIndex = 1;
	[SerializeField]
	private int spawnCount = 3;
	[SerializeField]
	float spawnDelay = 0.2f;
	[SerializeField]
	Pickup pickupRef = null;

	[SerializeField]
	Color colorPath = new Color(1f, 0.6f, 0f);
	[SerializeField]
	Color colorPathPhase2 = new Color(1f, 0.9f, 0f);

	Color colorLink2SpawnPt = new Color(0.0f, 0.7f, 0.9f);
	Color colorLink2SpawnProp = new Color(0.9f, 0.0f, 0.9f);
	int enemiesKilled;
	int enemiesSpawned;
	bool isSpawnPropKilled;
	//Transform[] miscPoints;
	SpawnerProp spawnProp;


	protected override void DoOnAwake()
	{
		//SpawnerMiscPoints smp = GetComponent<SpawnerMiscPoints>();
		//if (smp != null)
		//{
		//	miscPoints = smp.points;
		//}
	}


	public void InitFromSpawnProp(SpawnerProp sp)
	{
		spawnProp = sp;
		if (spawnProp.HealthManager != null)
			spawnProp.HealthManager.OnKilledInstance += HandleOnSpawnPropKilled;
		isSpawnPropKilled = false;
	}


	public Transform[] GetWaypoints()
	{
		return wayPoints;
	}


	public Vector2[] GetPath()
	{
		return path;
	}


	public void SetPath(Vector2[] pts)
	{
		path = pts;
	}


	public int GetPhase2WpIndex()
	{
		return phase2WpIndex;
	}


	public void UpdatePhase2PathIndex(int resolutionMultiplier)
	{
		phase2PathIndex = phase2WpIndex * resolutionMultiplier;
	}


	public int GetPhase2PathIndex()
	{
		return phase2PathIndex;
	}


	public bool GetIsSmooth()
	{
		return isSmooth;
	}


	void OnEnable()
	{
		enemiesKilled = 0;
		enemiesSpawned = 0;

		StartCoroutine(CoSpawnSeries());
	}


	void OnDisable()
	{
		if (spawnProp != null)
		{
			if (spawnProp.HealthManager != null)
				spawnProp.HealthManager.OnKilledInstance -= HandleOnSpawnPropKilled;
		}
	}


	void HandleOnSpawnPropKilled()
	{
		isSpawnPropKilled = true;

		//Unregister from instance events
		spawnProp.HealthManager.OnKilledInstance -= HandleOnSpawnPropKilled;
	}


	private IEnumerator CoSpawnSeries()
	{
		yield return null;
		float nextSpawnTime = -1f;
		for (int i = 0; i < spawnCount; i++)
		{
			while (Time.time < nextSpawnTime)
			{
				yield return null;
			}
			SpawnOneEnemy();
			nextSpawnTime = Time.time + spawnDelay;
		}

		//At the end we potentially trigger the rest
		TriggerOthersAndFinish();
	}


	void SpawnOneEnemy()
	{
		EnemyMovePath e = Instantiate<EnemyMovePath>(enemyToSpawnRef);
		e.Init(this);

		EnemyHealth eh = e.gameObject.GetComponent<EnemyHealth>();
		if (eh != null)
			eh.Register(this);

		//if (miscPoints != null)
		//{
		//	EnemyMiscPointsHolder msh = e.gameObject.GetComponent<EnemyMiscPointsHolder>();
		//	if (msh != null)
		//	{
		//		msh.setPointsList(miscPoints);
		//	}
		//}

		enemiesSpawned++;
	}


	//Called by EnemyMove or EnemyHEalth when an enemy generated by this spawner, is destroyed
	public void DoOnEnemyDestroyed(bool isKilled, Vector3 pos)
	{
		if (isKilled)
		{
			enemiesKilled++;
			//print("killed = " + enemiesKilled + " spawnCount = " + spawnCount);//TEST
			if (enemiesKilled == spawnCount || (isSpawnPropKilled && enemiesKilled == enemiesSpawned))
			{
				MayGivePickup(pos);
			}
		}
	}


	private void MayGivePickup(Vector3 pos)
	{
		if (pickupRef != null)
		{
			Instantiate(pickupRef, pos, Quaternion.identity);
		}
	}


	void OnDrawGizmos()
	{
		if (path != null)
		{
			//drawing the line from this Spawner object to the first waypoint (i.e. the spawnpoint)
			if (path.Length > 0 && path[0] != null)
			{
				Gizmos.color = colorLink2SpawnPt;
				Gizmos.DrawLine(transform.position, path[0]);
			}

			if (path.Length > 1)
			{
				//drawing the lines between path points
				for (int i = 0; i < path.Length - 1; i++)
				{
					if (path[i] == null || path[i + 1] == null)
						continue;

					//Gizmos.color = (i < phase2WpIndex) ? colorPath : colorPathPhase2;
					if (i < phase2PathIndex)
					{
						Gizmos.color = colorPath;
					}
					else
					{
						Gizmos.color = colorPathPhase2;
					}
					Gizmos.DrawLine(path[i], path[i + 1]);
				}

				//additional visual signs on specific points
				if (path[0] != null)
				{
					Gizmos.color = colorPath;
					Gizmos.DrawWireCube(path[0], Vector3.one);
				}
				int indexToDrawPhase2Gizmo = phase2PathIndex < path.Length ? phase2PathIndex : Mathf.Max(path.Length - 1, 0);
				Gizmos.color = colorPathPhase2;
				Gizmos.DrawWireSphere(path[indexToDrawPhase2Gizmo], 0.35f);
			}

			//drawing a line between the potential spawn prop object and this spawner
			if (spawnProp != null)
			{
				Gizmos.color = colorLink2SpawnProp;
				Gizmos.DrawLine(transform.position, spawnProp.transform.position);
			}
		}
	}

}
